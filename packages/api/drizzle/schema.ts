import {
  pgTable,
  index,
  unique,
  text,
  timestamp,
  date,
  boolean,
  jsonb,
  integer,
  doublePrecision,
  bigint,
  pgEnum,
} from "drizzle-orm/pg-core";

export const auditAction = pgEnum("AuditAction", [
  "CREATE",
  "UPDATE",
  "DELETE",
  "LOGIN",
  "LOGOUT",
  "APPROVE",
  "REJECT",
]);
export const backupStatus = pgEnum("BackupStatus", [
  "PENDING",
  "IN_PROGRESS",
  "COMPLETED",
  "FAILED",
  "DELETED",
]);
export const backupType = pgEnum("BackupType", [
  "DAILY",
  "WEEKLY",
  "MONTHLY",
  "MANUAL",
]);
export const eventType = pgEnum("EventType", [
  "BIRTH",
  "DEATH",
  "MARRIAGE",
  "DIVORCE",
  "BURIAL",
  "GRADUATION",
  "ENGAGEMENT",
  "DIVORCE_FILED",
  "ADOPTION",
  "CONFIRMATION",
  "IMMIGRATION",
  "EMIGRATION",
  "NATURALIZATION",
  "RESIDENCE",
  "CUSTOM",
]);
export const gender = pgEnum("Gender", [
  "MALE",
  "FEMALE",
  "OTHER",
  "PREFER_NOT_TO_SAY",
]);
export const inviteStatus = pgEnum("InviteStatus", [
  "PENDING",
  "ACCEPTED",
  "EXPIRED",
  "REVOKED",
]);
export const personPlaceType = pgEnum("PersonPlaceType", [
  "BIRTH",
  "MARRIAGE",
  "DEATH",
  "LIVED",
  "WORKED",
  "STUDIED",
  "OTHER",
]);
export const placeType = pgEnum("PlaceType", [
  "COUNTRY",
  "STATE",
  "COUNTY",
  "CITY",
  "TOWN",
  "VILLAGE",
  "PARISH",
  "DISTRICT",
  "REGION",
  "PROVINCE",
  "TERRITORY",
  "OTHER",
]);
export const privacyLevel = pgEnum("PrivacyLevel", [
  "PUBLIC",
  "MEMBERS_ONLY",
  "ADMIN_ONLY",
]);
export const profileClaimStatus = pgEnum("ProfileClaimStatus", [
  "PENDING",
  "CLAIMED",
  "SKIPPED",
  "NA",
]);
export const relationshipType = pgEnum("RelationshipType", [
  "PARENT",
  "CHILD",
  "SPOUSE",
  "SIBLING",
  "PARENT_IN_LAW",
  "CHILD_IN_LAW",
  "SIBLING_IN_LAW",
  "STEP_PARENT",
  "STEP_CHILD",
  "STEP_SIBLING",
]);
export const storageProvider = pgEnum("StorageProvider", [
  "LOCAL",
  "S3",
  "R2",
  "B2",
]);
export const suggestionStatus = pgEnum("SuggestionStatus", [
  "PENDING",
  "APPROVED",
  "REJECTED",
]);
export const suggestionType = pgEnum("SuggestionType", [
  "CREATE",
  "UPDATE",
  "DELETE",
  "ADD_RELATIONSHIP",
]);
export const userRole = pgEnum("UserRole", ["ADMIN", "MEMBER", "VIEWER"]);

export const account = pgTable(
  "Account",
  {
    id: text().primaryKey().notNull(),
    userId: text().notNull(),
    accountId: text().notNull(),
    providerId: text().notNull(),
    accessToken: text(),
    refreshToken: text(),
    accessTokenExpiresAt: timestamp({ mode: "string" }),
    refreshTokenExpiresAt: timestamp({ mode: "string" }),
    scope: text(),
    idToken: text(),
    password: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_account_userId").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops")
    ),
    unique("Account_providerId_accountId_unique").on(
      table.providerId,
      table.accountId
    ),
  ]
);

export const session = pgTable(
  "Session",
  {
    id: text().primaryKey().notNull(),
    token: text().notNull(),
    userId: text().notNull(),
    expiresAt: timestamp({ mode: "string" }).notNull(),
    ipAddress: text(),
    userAgent: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_session_expiresAt").using(
      "btree",
      table.expiresAt.asc().nullsLast().op("timestamp_ops")
    ),
    index("idx_session_userId").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops")
    ),
    unique("Session_token_unique").on(table.token),
  ]
);

export const relationship = pgTable(
  "Relationship",
  {
    id: text().primaryKey().notNull(),
    personId: text().notNull(),
    relatedPersonId: text().notNull(),
    type: relationshipType().notNull(),
    marriageDate: date(),
    divorceDate: date(),
    isActive: boolean().default(true).notNull(),
    isAutoGenerated: boolean().default(false).notNull(),
    sourceRelationshipId: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_relationship_isAutoGenerated").using(
      "btree",
      table.isAutoGenerated.asc().nullsLast().op("bool_ops")
    ),
    index("idx_relationship_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    index("idx_relationship_personId_type").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops"),
      table.type.asc().nullsLast().op("enum_ops")
    ),
    index("idx_relationship_relatedPersonId").using(
      "btree",
      table.relatedPersonId.asc().nullsLast().op("text_ops")
    ),
    index("idx_relationship_relatedPersonId_type").using(
      "btree",
      table.relatedPersonId.asc().nullsLast().op("text_ops"),
      table.type.asc().nullsLast().op("enum_ops")
    ),
    index("idx_relationship_sourceRelationshipId").using(
      "btree",
      table.sourceRelationshipId.asc().nullsLast().op("text_ops")
    ),
    unique("Relationship_personId_relatedPersonId_type_unique").on(
      table.type,
      table.relatedPersonId,
      table.personId
    ),
  ]
);

export const person = pgTable(
  "Person",
  {
    id: text().primaryKey().notNull(),
    firstName: text().notNull(),
    lastName: text().notNull(),
    maidenName: text(),
    dateOfBirth: date(),
    dateOfPassing: date(),
    birthPlace: text(),
    nativePlace: text(),
    gender: gender(),
    photoUrl: text(),
    bio: text(),
    email: text(),
    phone: text(),
    currentAddress: jsonb(),
    workAddress: jsonb(),
    profession: text(),
    employer: text(),
    socialLinks: jsonb(),
    isLiving: boolean().default(true).notNull(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
    createdById: text(),
    deletedAt: timestamp({ mode: "string" }),
  },
  (table) => [
    index("idx_person_createdById").using(
      "btree",
      table.createdById.asc().nullsLast().op("text_ops")
    ),
    index("idx_person_dateOfBirth").using(
      "btree",
      table.dateOfBirth.asc().nullsLast().op("date_ops")
    ),
    index("idx_person_isLiving").using(
      "btree",
      table.isLiving.asc().nullsLast().op("bool_ops")
    ),
    index("idx_person_lastName_firstName").using(
      "btree",
      table.lastName.asc().nullsLast().op("text_ops"),
      table.firstName.asc().nullsLast().op("text_ops")
    ),
  ]
);

export const user = pgTable(
  "User",
  {
    id: text().primaryKey().notNull(),
    email: text().notNull(),
    name: text(),
    image: text(),
    passwordHash: text(),
    personId: text(),
    role: userRole().default("VIEWER").notNull(),
    isActive: boolean().default(true).notNull(),
    mustChangePassword: boolean().default(false).notNull(),
    preferredLanguage: text().default("en"),
    oidcProvider: text(),
    oidcSubject: text(),
    emailVerified: boolean().default(false).notNull(),
    profileClaimStatus: profileClaimStatus().default("PENDING").notNull(),
    profileClaimedAt: timestamp({ mode: "string" }),
    invitedById: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
    lastLoginAt: timestamp({ mode: "string" }),
    failedLoginAttempts: integer().default(0).notNull(),
    lockedUntil: timestamp({ mode: "string" }),
    lastFailedLoginAt: timestamp({ mode: "string" }),
    emailNotificationPreferences: jsonb().default({
      newMemberJoined: true,
      birthdayReminders: true,
      suggestionsCreated: true,
      suggestionsUpdated: true,
    }),
  },
  (table) => [
    index("idx_user_email").using(
      "btree",
      table.email.asc().nullsLast().op("text_ops")
    ),
    index("idx_user_oidcProvider").using(
      "btree",
      table.oidcProvider.asc().nullsLast().op("text_ops")
    ),
    index("idx_user_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    unique("User_email_unique").on(table.email),
    unique("User_personId_unique").on(table.personId),
    unique("User_oidcProvider_oidcSubject_unique").on(
      table.oidcSubject,
      table.oidcProvider
    ),
  ]
);

export const verification = pgTable(
  "Verification",
  {
    id: text().primaryKey().notNull(),
    identifier: text().notNull(),
    value: text().notNull(),
    expiresAt: timestamp({ mode: "string" }).notNull(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_verification_identifier").using(
      "btree",
      table.identifier.asc().nullsLast().op("text_ops")
    ),
  ]
);

export const calendarToken = pgTable(
  "CalendarToken",
  {
    id: text().primaryKey().notNull(),
    token: text().notNull(),
    userId: text().notNull(),
    name: text(),
    expiresAt: timestamp({ mode: "string" }).notNull(),
    isActive: boolean().default(true).notNull(),
    lastUsedAt: timestamp({ mode: "string" }),
    rotationPolicy: text().default("annual").notNull(),
    rotatedAt: timestamp({ mode: "string" }),
    rotatedFrom: text(),
    scopes: text().array().default(["calendar:read"]),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("idx_calendarToken_expiresAt").using(
      "btree",
      table.expiresAt.asc().nullsLast().op("timestamp_ops")
    ),
    index("idx_calendarToken_isActive").using(
      "btree",
      table.isActive.asc().nullsLast().op("bool_ops")
    ),
    index("idx_calendarToken_token").using(
      "btree",
      table.token.asc().nullsLast().op("text_ops")
    ),
    index("idx_calendarToken_userId").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops")
    ),
    index("idx_calendarToken_userId_isActive").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops"),
      table.isActive.asc().nullsLast().op("text_ops")
    ),
    unique("CalendarToken_token_unique").on(table.token),
  ]
);

export const oauthState = pgTable(
  "OAuthState",
  {
    id: text().primaryKey().notNull(),
    state: text().notNull(),
    codeVerifier: text().notNull(),
    provider: text().notNull(),
    redirectTo: text(),
    expiresAt: timestamp({ mode: "string" }).notNull(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("idx_oAuthState_expiresAt").using(
      "btree",
      table.expiresAt.asc().nullsLast().op("timestamp_ops")
    ),
    index("idx_oAuthState_state").using(
      "btree",
      table.state.asc().nullsLast().op("text_ops")
    ),
    unique("OAuthState_state_unique").on(table.state),
  ]
);

export const eventMedia = pgTable(
  "EventMedia",
  {
    id: text().primaryKey().notNull(),
    mediaId: text().notNull(),
    personId: text().notNull(),
    eventType: text().notNull(),
  },
  (table) => [
    index("idx_eventMedia_eventType").using(
      "btree",
      table.eventType.asc().nullsLast().op("text_ops")
    ),
    index("idx_eventMedia_mediaId").using(
      "btree",
      table.mediaId.asc().nullsLast().op("text_ops")
    ),
    index("idx_eventMedia_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    unique("EventMedia_mediaId_personId_eventType_unique").on(
      table.personId,
      table.mediaId,
      table.eventType
    ),
  ]
);

export const eventParticipant = pgTable(
  "EventParticipant",
  {
    id: text().primaryKey().notNull(),
    eventId: text().notNull(),
    personId: text().notNull(),
    role: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("idx_eventParticipant_eventId").using(
      "btree",
      table.eventId.asc().nullsLast().op("text_ops")
    ),
    index("idx_eventParticipant_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    unique("EventParticipant_eventId_personId_unique").on(
      table.personId,
      table.eventId
    ),
  ]
);

export const eventSource = pgTable(
  "EventSource",
  {
    id: text().primaryKey().notNull(),
    sourceId: text().notNull(),
    personId: text().notNull(),
    eventType: text().notNull(),
    confidence: text(),
    sourceNotes: text(),
  },
  (table) => [
    index("idx_eventSource_eventType").using(
      "btree",
      table.eventType.asc().nullsLast().op("text_ops")
    ),
    index("idx_eventSource_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    index("idx_eventSource_sourceId").using(
      "btree",
      table.sourceId.asc().nullsLast().op("text_ops")
    ),
    unique("EventSource_sourceId_personId_eventType_unique").on(
      table.sourceId,
      table.personId,
      table.eventType
    ),
  ]
);

export const event = pgTable(
  "Event",
  {
    id: text().primaryKey().notNull(),
    personId: text().notNull(),
    type: eventType().notNull(),
    date: date(),
    place: text(),
    placeId: text(),
    description: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_event_date").using(
      "btree",
      table.date.asc().nullsLast().op("date_ops")
    ),
    index("idx_event_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    index("idx_event_placeId").using(
      "btree",
      table.placeId.asc().nullsLast().op("text_ops")
    ),
    index("idx_event_type").using(
      "btree",
      table.type.asc().nullsLast().op("enum_ops")
    ),
  ]
);

export const placePersonLink = pgTable(
  "PlacePersonLink",
  {
    id: text().primaryKey().notNull(),
    personId: text().notNull(),
    placeId: text().notNull(),
    fromYear: integer(),
    toYear: integer(),
    type: personPlaceType(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("idx_placePersonLink_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    index("idx_placePersonLink_placeId").using(
      "btree",
      table.placeId.asc().nullsLast().op("text_ops")
    ),
    unique("PlacePersonLink_personId_placeId_type_unique").on(
      table.type,
      table.placeId,
      table.personId
    ),
  ]
);

export const place = pgTable(
  "Place",
  {
    id: text().primaryKey().notNull(),
    name: text().notNull(),
    placeType: placeType().notNull(),
    latitude: doublePrecision(),
    longitude: doublePrecision(),
    parentId: text(),
    description: text(),
    alternativeNames: jsonb(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_place_latitude_longitude").using(
      "btree",
      table.latitude.asc().nullsLast().op("float8_ops"),
      table.longitude.asc().nullsLast().op("float8_ops")
    ),
    index("idx_place_name").using(
      "btree",
      table.name.asc().nullsLast().op("text_ops")
    ),
    index("idx_place_parentId").using(
      "btree",
      table.parentId.asc().nullsLast().op("text_ops")
    ),
    index("idx_place_placeType").using(
      "btree",
      table.placeType.asc().nullsLast().op("enum_ops")
    ),
  ]
);

export const mediaObject = pgTable(
  "MediaObject",
  {
    id: text().primaryKey().notNull(),
    filePath: text().notNull(),
    format: text().notNull(),
    mimeType: text().notNull(),
    fileSize: integer().notNull(),
    title: text(),
    description: text(),
    source: text(),
    width: integer(),
    height: integer(),
    thumbnailPath: text(),
    webpPath: text(),
    thumb400Path: text(),
    thumb800Path: text(),
    thumb1200Path: text(),
    uploadedAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_mediaObject_filePath").using(
      "btree",
      table.filePath.asc().nullsLast().op("text_ops")
    ),
    index("idx_mediaObject_uploadedAt").using(
      "btree",
      table.uploadedAt.asc().nullsLast().op("timestamp_ops")
    ),
  ]
);

export const personMedia = pgTable(
  "PersonMedia",
  {
    id: text().primaryKey().notNull(),
    personId: text().notNull(),
    mediaId: text().notNull(),
    isPrimary: boolean().default(false).notNull(),
    caption: text(),
    displayOrder: integer().notNull(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_personMedia_isPrimary").using(
      "btree",
      table.isPrimary.asc().nullsLast().op("bool_ops")
    ),
    index("idx_personMedia_mediaId").using(
      "btree",
      table.mediaId.asc().nullsLast().op("text_ops")
    ),
    index("idx_personMedia_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    unique("PersonMedia_personId_mediaId_unique").on(
      table.personId,
      table.mediaId
    ),
  ]
);

export const backupSettings = pgTable("BackupSettings", {
  id: text().primaryKey().notNull(),
  dailyEnabled: boolean().default(true).notNull(),
  dailyTime: text().default("02:00").notNull(),
  weeklyEnabled: boolean().default(true).notNull(),
  weeklyDay: integer().default(0).notNull(),
  weeklyTime: text().default("03:00").notNull(),
  monthlyEnabled: boolean().default(true).notNull(),
  monthlyDay: integer().default(1).notNull(),
  monthlyTime: text().default("04:00").notNull(),
  dailyRetention: integer().default(7).notNull(),
  weeklyRetention: integer().default(4).notNull(),
  monthlyRetention: integer().default(12).notNull(),
  storageProvider: storageProvider().default("LOCAL").notNull(),
  storageBucket: text(),
  storageRegion: text(),
  storagePath: text().default("backups").notNull(),
  includePhotos: boolean().default(true).notNull(),
  includeAuditLogs: boolean().default(false).notNull(),
  compressLevel: integer().default(6).notNull(),
  notifyOnSuccess: boolean().default(false).notNull(),
  notifyOnFailure: boolean().default(true).notNull(),
  notificationEmails: jsonb(),
  createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  updatedAt: timestamp({ mode: "string" }).notNull(),
});

export const backup = pgTable(
  "Backup",
  {
    id: text().primaryKey().notNull(),
    filename: text().notNull(),
    type: backupType().notNull(),
    status: backupStatus().default("PENDING").notNull(),
    // You can use { mode: "bigint" } if numbers are exceeding js number limitations
    size: bigint({ mode: "number" }),
    location: storageProvider().default("LOCAL").notNull(),
    personCount: integer(),
    relationshipCount: integer(),
    eventCount: integer(),
    mediaCount: integer(),
    duration: integer(),
    error: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    deletedAt: timestamp({ mode: "string" }),
  },
  (table) => [
    index("idx_backup_createdAt").using(
      "btree",
      table.createdAt.asc().nullsLast().op("timestamp_ops")
    ),
    index("idx_backup_status").using(
      "btree",
      table.status.asc().nullsLast().op("enum_ops")
    ),
    index("idx_backup_type_createdAt").using(
      "btree",
      table.type.asc().nullsLast().op("enum_ops"),
      table.createdAt.asc().nullsLast().op("timestamp_ops")
    ),
  ]
);

export const auditLog = pgTable(
  "AuditLog",
  {
    id: text().primaryKey().notNull(),
    userId: text().notNull(),
    action: auditAction().notNull(),
    entityType: text().notNull(),
    entityId: text(),
    previousData: jsonb(),
    newData: jsonb(),
    ipAddress: text(),
    userAgent: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("idx_auditLog_createdAt").using(
      "btree",
      table.createdAt.asc().nullsLast().op("timestamp_ops")
    ),
    index("idx_auditLog_entityType_entityId").using(
      "btree",
      table.entityType.asc().nullsLast().op("text_ops"),
      table.entityId.asc().nullsLast().op("text_ops")
    ),
    index("idx_auditLog_userId").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops")
    ),
  ]
);

export const emailLog = pgTable(
  "EmailLog",
  {
    id: text().primaryKey().notNull(),
    recipientEmail: text().notNull(),
    subject: text().notNull(),
    emailType: text().notNull(),
    status: text().default("sent").notNull(),
    sentAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    error: text(),
    resendId: text(),
    metadata: jsonb(),
    createdById: text().notNull(),
  },
  (table) => [
    index("idx_emailLog_emailType").using(
      "btree",
      table.emailType.asc().nullsLast().op("text_ops")
    ),
    index("idx_emailLog_recipientEmail").using(
      "btree",
      table.recipientEmail.asc().nullsLast().op("text_ops")
    ),
    index("idx_emailLog_sentAt").using(
      "btree",
      table.sentAt.asc().nullsLast().op("timestamp_ops")
    ),
    index("idx_emailLog_status").using(
      "btree",
      table.status.asc().nullsLast().op("text_ops")
    ),
  ]
);

export const familySettings = pgTable("FamilySettings", {
  id: text().primaryKey().notNull(),
  familyName: text().default("Our Family").notNull(),
  description: text(),
  locale: text().default("en").notNull(),
  customLabels: jsonb(),
  defaultPrivacy: privacyLevel().default("MEMBERS_ONLY").notNull(),
  allowSelfRegistration: boolean().default(true).notNull(),
  requireApprovalForEdits: boolean().default(true).notNull(),
  metricsDashboardUrl: text(),
  metricsApiUrl: text(),
  createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  updatedAt: timestamp({ mode: "string" }).notNull(),
});

export const invite = pgTable(
  "Invite",
  {
    id: text().primaryKey().notNull(),
    email: text().notNull(),
    personId: text(),
    role: userRole().default("MEMBER").notNull(),
    invitedById: text().notNull(),
    token: text().notNull(),
    expiresAt: timestamp({ mode: "string" }).notNull(),
    acceptedAt: timestamp({ mode: "string" }),
    status: inviteStatus().default("PENDING").notNull(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("idx_invite_email").using(
      "btree",
      table.email.asc().nullsLast().op("text_ops")
    ),
    index("idx_invite_invitedById").using(
      "btree",
      table.invitedById.asc().nullsLast().op("text_ops")
    ),
    index("idx_invite_status").using(
      "btree",
      table.status.asc().nullsLast().op("enum_ops")
    ),
    unique("Invite_token_unique").on(table.token),
  ]
);

export const researchNote = pgTable(
  "ResearchNote",
  {
    id: text().primaryKey().notNull(),
    sourceId: text().notNull(),
    personId: text().notNull(),
    eventType: text().notNull(),
    findings: text().notNull(),
    methodology: text(),
    limitations: text(),
    relatedSources: text(),
    conclusionReliability: text(),
    createdById: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_researchNote_createdById").using(
      "btree",
      table.createdById.asc().nullsLast().op("text_ops")
    ),
    index("idx_researchNote_eventType").using(
      "btree",
      table.eventType.asc().nullsLast().op("text_ops")
    ),
    index("idx_researchNote_personId").using(
      "btree",
      table.personId.asc().nullsLast().op("text_ops")
    ),
    index("idx_researchNote_sourceId").using(
      "btree",
      table.sourceId.asc().nullsLast().op("text_ops")
    ),
  ]
);

export const source = pgTable(
  "Source",
  {
    id: text().primaryKey().notNull(),
    title: text().notNull(),
    author: text(),
    publicationDate: text(),
    description: text(),
    repository: text(),
    notes: text(),
    sourceType: text(),
    citationFormat: text(),
    doi: text(),
    url: text(),
    isbn: text(),
    callNumber: text(),
    accessDate: timestamp({ mode: "string" }),
    confidence: text(),
    createdAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp({ mode: "string" }).notNull(),
  },
  (table) => [
    index("idx_source_doi").using(
      "btree",
      table.doi.asc().nullsLast().op("text_ops")
    ),
    index("idx_source_sourceType").using(
      "btree",
      table.sourceType.asc().nullsLast().op("text_ops")
    ),
    index("idx_source_title").using(
      "btree",
      table.title.asc().nullsLast().op("text_ops")
    ),
  ]
);

export const suggestion = pgTable(
  "Suggestion",
  {
    id: text().primaryKey().notNull(),
    type: suggestionType().notNull(),
    targetPersonId: text(),
    suggestedData: jsonb().notNull(),
    reason: text(),
    status: suggestionStatus().default("PENDING").notNull(),
    submittedById: text().notNull(),
    reviewedById: text(),
    reviewNote: text(),
    submittedAt: timestamp({ mode: "string" }).defaultNow().notNull(),
    reviewedAt: timestamp({ mode: "string" }),
  },
  (table) => [
    index("idx_suggestion_status").using(
      "btree",
      table.status.asc().nullsLast().op("enum_ops")
    ),
    index("idx_suggestion_submittedById").using(
      "btree",
      table.submittedById.asc().nullsLast().op("text_ops")
    ),
    index("idx_suggestion_targetPersonId").using(
      "btree",
      table.targetPersonId.asc().nullsLast().op("text_ops")
    ),
  ]
);
