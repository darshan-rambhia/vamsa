generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum UserRole {
  ADMIN
  MEMBER
  VIEWER
}

enum RelationshipType {
  // Core family relationships
  PARENT
  CHILD
  SPOUSE
  SIBLING

  // In-law relationships (derived from marriage)
  PARENT_IN_LAW    // Spouse's parent
  CHILD_IN_LAW     // Child's spouse
  SIBLING_IN_LAW   // Spouse's sibling OR sibling's spouse

  // Step relationships (derived from remarriage)
  STEP_PARENT      // Parent's new spouse
  STEP_CHILD       // Spouse's child from previous relationship
  STEP_SIBLING     // Step-parent's child
}

enum SuggestionType {
  CREATE
  UPDATE
  DELETE
  ADD_RELATIONSHIP
}

enum SuggestionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum PrivacyLevel {
  PUBLIC
  MEMBERS_ONLY
  ADMIN_ONLY
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  APPROVE
  REJECT
}

enum InviteStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

enum ProfileClaimStatus {
  PENDING   // User hasn't claimed or skipped
  CLAIMED   // User claimed a person profile
  SKIPPED   // User explicitly skipped claiming
  NA        // Not applicable (password user with personId set)
}

enum EventType {
  BIRTH
  DEATH
  MARRIAGE
  DIVORCE
  BURIAL
  GRADUATION
  ENGAGEMENT
  DIVORCE_FILED
  ADOPTION
  CONFIRMATION
  IMMIGRATION
  EMIGRATION
  NATURALIZATION
  RESIDENCE
  CUSTOM
}

enum PlaceType {
  COUNTRY
  STATE
  COUNTY
  CITY
  TOWN
  VILLAGE
  PARISH
  DISTRICT
  REGION
  PROVINCE
  TERRITORY
  OTHER
}

enum PersonPlaceType {
  BIRTH
  MARRIAGE
  DEATH
  LIVED
  WORKED
  STUDIED
  OTHER
}

model Person {
  id            String    @id @default(cuid())
  firstName     String
  lastName      String
  maidenName    String?
  dateOfBirth   DateTime? @db.Date
  dateOfPassing DateTime? @db.Date
  birthPlace    String?
  nativePlace   String?
  gender        Gender?
  photoUrl      String?
  bio           String?

  email          String?
  phone          String?
  currentAddress Json?
  workAddress    Json?

  profession String?
  employer   String?

  socialLinks Json?

  isLiving Boolean @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?

  createdBy User? @relation("PersonCreatedBy", fields: [createdById], references: [id])
  user      User? @relation("UserPerson")

  relationshipsFrom Relationship[] @relation("RelationshipFrom")
  relationshipsTo   Relationship[] @relation("RelationshipTo")

  suggestions Suggestion[] @relation("SuggestionTarget")

  events            Event[]            @relation("PersonEvents")
  eventParticipants EventParticipant[] @relation("PersonEventParticipants")

  eventSources EventSource[] @relation("PersonEventSources")
  eventMedia   EventMedia[]  @relation("PersonEventMedia")
  invites      Invite[]      @relation("InvitePerson")

  placeLinks    PlacePersonLink[] @relation("PersonPlaces")
  mediaObjects  PersonMedia[]     @relation("PersonMediaObjects")
  researchNotes ResearchNote[]    @relation("PersonResearchNotes")

  @@index([lastName, firstName])
  @@index([createdById])
  @@index([dateOfBirth])  // For birthday queries and age-based filters
  @@index([isLiving])     // For living/deceased filters
}

model Relationship {
  id              String           @id @default(cuid())
  personId        String
  relatedPersonId String
  type            RelationshipType

  marriageDate DateTime? @db.Date
  divorceDate  DateTime? @db.Date
  isActive     Boolean   @default(true)

  // Track auto-generated in-law/step relationships
  isAutoGenerated      Boolean @default(false)
  sourceRelationshipId String? // The relationship that caused this one to be created

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  person        Person @relation("RelationshipFrom", fields: [personId], references: [id], onDelete: Cascade)
  relatedPerson Person @relation("RelationshipTo", fields: [relatedPersonId], references: [id], onDelete: Cascade)

  // Self-referential relation for tracking derived relationships
  sourceRelationship   Relationship?  @relation("DerivedRelationships", fields: [sourceRelationshipId], references: [id], onDelete: Cascade)
  derivedRelationships Relationship[] @relation("DerivedRelationships")

  @@unique([personId, relatedPersonId, type])
  @@index([personId])
  @@index([relatedPersonId])
  @@index([personId, type])        // For relationship queries by person and type
  @@index([relatedPersonId, type]) // For reverse lookups by type
  @@index([sourceRelationshipId])
  @@index([isAutoGenerated])
}

model User {
  id                 String   @id @default(cuid())
  email              String   @unique
  name               String?
  passwordHash       String?
  personId           String?  @unique
  role               UserRole @default(VIEWER)
  isActive           Boolean  @default(true)
  mustChangePassword Boolean  @default(false)
  preferredLanguage  String?  @default("en")

  // OIDC/SSO fields
  oidcProvider  String?  // "google", "microsoft", "github"
  oidcSubject   String?  // Provider-specific user ID (sub claim)
  emailVerified Boolean  @default(false)

  // Profile claiming for OIDC users
  profileClaimStatus ProfileClaimStatus @default(PENDING)
  profileClaimedAt   DateTime?

  invitedById String?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // Account lockout fields
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?
  lastFailedLoginAt   DateTime?

  emailNotificationPreferences Json? @default("{\"suggestionsCreated\":true,\"suggestionsUpdated\":true,\"newMemberJoined\":true,\"birthdayReminders\":true}")

  person    Person? @relation("UserPerson", fields: [personId], references: [id])
  invitedBy User?   @relation("UserInvites", fields: [invitedById], references: [id])
  invitees  User[]  @relation("UserInvites")

  createdPeople Person[] @relation("PersonCreatedBy")

  submittedSuggestions Suggestion[] @relation("SuggestionSubmitter")
  reviewedSuggestions  Suggestion[] @relation("SuggestionReviewer")

  auditLogs      AuditLog[]
  sessions       Session[]
  invites        Invite[]       @relation("InvitedBy")
  researchNotes  ResearchNote[] @relation("ResearchNoteCreator")
  emailLogs      EmailLog[]      @relation("EmailLogCreator")
  calendarTokens CalendarToken[] @relation("CalendarTokens")

  @@unique([oidcProvider, oidcSubject])
  @@index([email])
  @@index([personId])
  @@index([oidcProvider])
}

model Session {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model CalendarToken {
  id             String    @id @default(cuid())
  token          String    @unique
  userId         String
  name           String?
  expiresAt      DateTime
  isActive       Boolean   @default(true)
  lastUsedAt     DateTime?
  rotationPolicy String    @default("annual")
  rotatedAt      DateTime?
  rotatedFrom    String?
  scopes         String[]  @default(["calendar:read"])

  createdAt DateTime @default(now())

  user User @relation("CalendarTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@index([isActive])
  @@index([userId, isActive])
}

model OAuthState {
  id           String   @id @default(cuid())
  state        String   @unique
  codeVerifier String   // PKCE code verifier
  provider     String   // "google", "microsoft", "github"
  redirectTo   String?  // Optional redirect after auth
  expiresAt    DateTime

  createdAt DateTime @default(now())

  @@index([state])
  @@index([expiresAt])
}

model Suggestion {
  id             String           @id @default(cuid())
  type           SuggestionType
  targetPersonId String?
  suggestedData  Json
  reason         String?
  status         SuggestionStatus @default(PENDING)

  submittedById String
  reviewedById  String?
  reviewNote    String?

  submittedAt DateTime  @default(now())
  reviewedAt  DateTime?

  targetPerson Person? @relation("SuggestionTarget", fields: [targetPersonId], references: [id], onDelete: Cascade)
  submittedBy  User    @relation("SuggestionSubmitter", fields: [submittedById], references: [id])
  reviewedBy   User?   @relation("SuggestionReviewer", fields: [reviewedById], references: [id])

  @@index([status])
  @@index([submittedById])
  @@index([targetPersonId])
}

model FamilySettings {
  id                      String       @id @default(cuid())
  familyName              String       @default("Our Family")
  description             String?
  locale                  String       @default("en")
  customLabels            Json?
  defaultPrivacy          PrivacyLevel @default(MEMBERS_ONLY)
  allowSelfRegistration   Boolean      @default(true)
  requireApprovalForEdits Boolean      @default(true)

  // Custom metrics URLs (override environment variables)
  metricsDashboardUrl String? // Custom Grafana/Datadog/etc. dashboard URL
  metricsApiUrl       String? // Custom Prometheus/metrics API URL

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AuditLog {
  id           String      @id @default(cuid())
  userId       String
  action       AuditAction
  entityType   String
  entityId     String?
  previousData Json?
  newData      Json?
  ipAddress    String?
  userAgent    String?

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
}

model Invite {
  id          String       @id @default(cuid())
  email       String
  personId    String?
  role        UserRole     @default(MEMBER)
  invitedById String
  token       String       @unique
  expiresAt   DateTime
  acceptedAt  DateTime?
  status      InviteStatus @default(PENDING)

  createdAt DateTime @default(now())

  person    Person? @relation("InvitePerson", fields: [personId], references: [id])
  invitedBy User    @relation("InvitedBy", fields: [invitedById], references: [id])

  @@index([email])
  @@index([invitedById])
  @@index([status])
}

// GEDCOM Phase 2: Source Citations Support
model Source {
  id              String    @id @default(cuid())
  title           String
  author          String?
  publicationDate String?
  description     String?
  repository      String?
  notes           String?
  sourceType      String?
  citationFormat  String?
  doi             String?
  url             String?
  isbn            String?
  callNumber      String?
  accessDate      DateTime?
  confidence      String?

  eventSources  EventSource[]  @relation("SourceEvents")
  researchNotes ResearchNote[] @relation("SourceResearchNotes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([title])
  @@index([sourceType])
  @@index([doi])
}

model ResearchNote {
  id                    String  @id @default(cuid())
  sourceId              String
  personId              String
  eventType             String
  findings              String
  methodology           String?
  limitations           String?
  relatedSources        String? // JSON array of source IDs
  conclusionReliability String?
  createdById           String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  source    Source @relation("SourceResearchNotes", fields: [sourceId], references: [id], onDelete: Cascade)
  person    Person @relation("PersonResearchNotes", fields: [personId], references: [id], onDelete: Cascade)
  createdBy User?  @relation("ResearchNoteCreator", fields: [createdById], references: [id], onDelete: SetNull)

  @@index([sourceId])
  @@index([personId])
  @@index([eventType])
  @@index([createdById])
}

model EventSource {
  id          String  @id @default(cuid())
  sourceId    String
  personId    String
  eventType   String
  confidence  String?
  sourceNotes String?

  source Source @relation("SourceEvents", fields: [sourceId], references: [id], onDelete: Cascade)
  person Person @relation("PersonEventSources", fields: [personId], references: [id], onDelete: Cascade)

  @@unique([sourceId, personId, eventType])
  @@index([sourceId])
  @@index([personId])
  @@index([eventType])
}

// GEDCOM Phase 2: Multimedia Object Support
model MediaObject {
  id            String   @id @default(cuid())
  filePath      String
  format        String
  mimeType      String
  fileSize      Int
  title         String?
  description   String?
  source        String?
  width         Int?
  height        Int?
  thumbnailPath String?

  // Optimized image paths
  webpPath      String?   // Path to WebP version
  thumb400Path  String?   // Path to 400px responsive size
  thumb800Path  String?   // Path to 800px responsive size
  thumb1200Path String?   // Path to 1200px responsive size

  uploadedAt    DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  eventMedia  EventMedia[]  @relation("MediaEvents")
  personMedia PersonMedia[] @relation("MediaPersonObjects")

  @@index([filePath])
  @@index([uploadedAt])
}

model EventMedia {
  id        String @id @default(cuid())
  mediaId   String
  personId  String
  eventType String

  media  MediaObject @relation("MediaEvents", fields: [mediaId], references: [id], onDelete: Cascade)
  person Person      @relation("PersonEventMedia", fields: [personId], references: [id], onDelete: Cascade)

  @@unique([mediaId, personId, eventType])
  @@index([mediaId])
  @@index([personId])
  @@index([eventType])
}

model PersonMedia {
  id           String  @id @default(cuid())
  personId     String
  mediaId      String
  isPrimary    Boolean @default(false)
  caption      String?
  displayOrder Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  person Person      @relation("PersonMediaObjects", fields: [personId], references: [id], onDelete: Cascade)
  media  MediaObject @relation("MediaPersonObjects", fields: [mediaId], references: [id], onDelete: Cascade)

  @@unique([personId, mediaId])
  @@index([personId])
  @@index([mediaId])
  @@index([isPrimary])
}

model Event {
  id          String    @id @default(cuid())
  personId    String
  type        EventType
  date        DateTime? @db.Date
  place       String?
  placeId     String?
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  person       Person             @relation("PersonEvents", fields: [personId], references: [id], onDelete: Cascade)
  placeRecord  Place?             @relation("EventPlaces", fields: [placeId], references: [id], onDelete: SetNull)
  participants EventParticipant[] @relation("EventParticipants")

  @@index([personId])
  @@index([type])
  @@index([date])
  @@index([placeId])
}

model EventParticipant {
  id       String  @id @default(cuid())
  eventId  String
  personId String
  role     String?

  createdAt DateTime @default(now())

  event  Event  @relation("EventParticipants", fields: [eventId], references: [id], onDelete: Cascade)
  person Person @relation("PersonEventParticipants", fields: [personId], references: [id], onDelete: Cascade)

  @@unique([eventId, personId])
  @@index([eventId])
  @@index([personId])
}

model Place {
  id               String    @id @default(cuid())
  name             String
  placeType        PlaceType
  latitude         Float?
  longitude        Float?
  parentId         String?
  description      String?
  alternativeNames Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parent      Place?            @relation("PlaceHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    Place[]           @relation("PlaceHierarchy")
  events      Event[]           @relation("EventPlaces")
  personLinks PlacePersonLink[] @relation("PlacePersonLinks")

  @@index([name])
  @@index([placeType])
  @@index([parentId])
  @@index([latitude, longitude])
}

model PlacePersonLink {
  id       String           @id @default(cuid())
  personId String
  placeId  String
  fromYear Int?
  toYear   Int?
  type     PersonPlaceType?

  createdAt DateTime @default(now())

  person Person @relation("PersonPlaces", fields: [personId], references: [id], onDelete: Cascade)
  place  Place  @relation("PlacePersonLinks", fields: [placeId], references: [id], onDelete: Cascade)

  @@unique([personId, placeId, type])
  @@index([personId])
  @@index([placeId])
}

model EmailLog {
  id              String   @id @default(cuid())
  recipientEmail  String
  subject         String
  emailType       String   // "suggestion_created", "suggestion_updated", "new_member", "birthday_reminder"
  status          String   @default("sent") // "sent", "failed", "bounced"
  sentAt          DateTime @default(now())
  error           String?
  resendId        String?  // Store Resend email ID for tracking
  metadata        Json?    // Store any additional metadata

  createdBy   User   @relation("EmailLogCreator", fields: [createdById], references: [id], onDelete: Cascade)
  createdById String

  @@index([recipientEmail])
  @@index([emailType])
  @@index([status])
  @@index([sentAt])
}

// Automated Backup System
enum BackupStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  DELETED
}

enum BackupType {
  DAILY
  WEEKLY
  MONTHLY
  MANUAL
}

enum StorageProvider {
  LOCAL
  S3
  R2      // Cloudflare R2
  B2      // Backblaze B2
}

model Backup {
  id        String       @id @default(cuid())
  filename  String
  type      BackupType
  status    BackupStatus @default(PENDING)
  size      BigInt?      // Size in bytes
  location  StorageProvider @default(LOCAL)

  // Statistics
  personCount       Int?
  relationshipCount Int?
  eventCount        Int?
  mediaCount        Int?

  // Timing
  duration Int? // milliseconds

  // Error tracking
  error String?

  createdAt DateTime  @default(now())
  deletedAt DateTime? // Soft delete for retention tracking

  @@index([type, createdAt])
  @@index([status])
  @@index([createdAt])
}

model BackupSettings {
  id String @id @default(cuid())

  // Schedule - Daily
  dailyEnabled Boolean @default(true)
  dailyTime    String  @default("02:00") // HH:MM format (UTC)

  // Schedule - Weekly
  weeklyEnabled Boolean @default(true)
  weeklyDay     Int     @default(0) // 0 = Sunday, 6 = Saturday
  weeklyTime    String  @default("03:00")

  // Schedule - Monthly
  monthlyEnabled Boolean @default(true)
  monthlyDay     Int     @default(1) // Day of month (1-28)
  monthlyTime    String  @default("04:00")

  // Retention (number of backups to keep)
  dailyRetention   Int @default(7)  // Keep 7 daily backups
  weeklyRetention  Int @default(4)  // Keep 4 weekly backups
  monthlyRetention Int @default(12) // Keep 12 monthly backups

  // Storage
  storageProvider StorageProvider @default(LOCAL)
  storageBucket   String?
  storageRegion   String?
  storagePath     String          @default("backups") // Prefix/path for storage

  // Options
  includePhotos    Boolean @default(true)
  includeAuditLogs Boolean @default(false) // Only include in monthly by default
  compressLevel    Int     @default(6)     // ZIP compression 0-9

  // Notifications
  notifyOnSuccess    Boolean @default(false)
  notifyOnFailure    Boolean @default(true)
  notificationEmails String? // JSON array of emails

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
