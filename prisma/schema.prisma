generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum UserRole {
  ADMIN
  MEMBER
  VIEWER
}

enum RelationshipType {
  PARENT
  CHILD
  SPOUSE
  SIBLING
}

enum SuggestionType {
  CREATE
  UPDATE
  DELETE
  ADD_RELATIONSHIP
}

enum SuggestionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum PrivacyLevel {
  PUBLIC
  MEMBERS_ONLY
  ADMIN_ONLY
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  APPROVE
  REJECT
}

model Person {
  id            String    @id @default(cuid())
  firstName     String
  lastName      String
  maidenName    String?
  dateOfBirth   DateTime? @db.Date
  dateOfPassing DateTime? @db.Date
  birthPlace    String?
  nativePlace   String?
  gender        Gender?
  photoUrl      String?
  bio           String?

  email         String?
  phone         String?
  currentAddress Json?
  workAddress    Json?

  profession    String?
  employer      String?

  socialLinks   Json?

  isLiving      Boolean   @default(true)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  createdById   String?

  createdBy     User?     @relation("PersonCreatedBy", fields: [createdById], references: [id])
  user          User?     @relation("UserPerson")

  relationshipsFrom Relationship[] @relation("RelationshipFrom")
  relationshipsTo   Relationship[] @relation("RelationshipTo")

  suggestions   Suggestion[] @relation("SuggestionTarget")

  eventSources  EventSource[] @relation("PersonEventSources")
  eventMedia    EventMedia[]  @relation("PersonEventMedia")

  @@index([lastName, firstName])
  @@index([createdById])
}

model Relationship {
  id              String           @id @default(cuid())
  personId        String
  relatedPersonId String
  type            RelationshipType

  marriageDate    DateTime? @db.Date
  divorceDate     DateTime? @db.Date
  isActive        Boolean          @default(true)

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  person          Person           @relation("RelationshipFrom", fields: [personId], references: [id], onDelete: Cascade)
  relatedPerson   Person           @relation("RelationshipTo", fields: [relatedPersonId], references: [id], onDelete: Cascade)

  @@unique([personId, relatedPersonId, type])
  @@index([personId])
  @@index([relatedPersonId])
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String?
  personId      String?   @unique
  role          UserRole  @default(VIEWER)
  isActive      Boolean   @default(true)
  mustChangePassword Boolean @default(false)

  invitedById   String?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?

  person        Person?   @relation("UserPerson", fields: [personId], references: [id])
  invitedBy     User?     @relation("UserInvites", fields: [invitedById], references: [id])
  invitees      User[]    @relation("UserInvites")

  createdPeople Person[]  @relation("PersonCreatedBy")

  submittedSuggestions Suggestion[] @relation("SuggestionSubmitter")
  reviewedSuggestions  Suggestion[] @relation("SuggestionReviewer")

  auditLogs     AuditLog[]

  sessions      Session[]
  accounts      Account[]

  @@index([email])
  @@index([personId])
}

model Suggestion {
  id              String           @id @default(cuid())
  type            SuggestionType
  targetPersonId  String?
  suggestedData   Json
  reason          String?
  status          SuggestionStatus @default(PENDING)

  submittedById   String
  reviewedById    String?
  reviewNote      String?

  submittedAt     DateTime         @default(now())
  reviewedAt      DateTime?

  targetPerson    Person?          @relation("SuggestionTarget", fields: [targetPersonId], references: [id], onDelete: Cascade)
  submittedBy     User             @relation("SuggestionSubmitter", fields: [submittedById], references: [id])
  reviewedBy      User?            @relation("SuggestionReviewer", fields: [reviewedById], references: [id])

  @@index([status])
  @@index([submittedById])
  @@index([targetPersonId])
}

model FamilySettings {
  id                    String       @id @default(cuid())
  familyName            String       @default("Our Family")
  description           String?
  locale                String       @default("en")
  customLabels          Json?
  defaultPrivacy        PrivacyLevel @default(MEMBERS_ONLY)
  allowSelfRegistration Boolean      @default(true)
  requireApprovalForEdits Boolean    @default(true)

  createdAt             DateTime     @default(now())
  updatedAt             DateTime     @updatedAt
}

model AuditLog {
  id            String      @id @default(cuid())
  userId        String
  action        AuditAction
  entityType    String
  entityId      String?
  previousData  Json?
  newData       Json?
  ipAddress     String?
  userAgent     String?

  createdAt     DateTime    @default(now())

  user          User        @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// GEDCOM Phase 2: Source Citations Support
model Source {
  id              String   @id @default(cuid())
  title           String
  author          String?
  publicationDate String?  // ISO date format
  description     String?
  repository      String?
  notes           String?

  eventSources    EventSource[] @relation("SourceEvents")

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([title])
}

// Join table for Event to Source relationships
model EventSource {
  id        String  @id @default(cuid())
  sourceId  String
  personId  String
  eventType String  // e.g., BIRT, DEAT, MARR, BURI, GRAD, etc.

  source    Source  @relation("SourceEvents", fields: [sourceId], references: [id], onDelete: Cascade)
  person    Person  @relation("PersonEventSources", fields: [personId], references: [id], onDelete: Cascade)

  @@unique([sourceId, personId, eventType])
  @@index([sourceId])
  @@index([personId])
  @@index([eventType])
}

// GEDCOM Phase 2: Multimedia Object Support
model MediaObject {
  id          String   @id @default(cuid())
  filePath    String
  format      String   // e.g., JPEG, PNG, PDF
  title       String?
  description String?

  eventMedia  EventMedia[] @relation("MediaEvents")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([filePath])
}

// Join table for Event to MediaObject relationships
model EventMedia {
  id           String  @id @default(cuid())
  mediaId      String
  personId     String
  eventType    String  // e.g., BIRT, DEAT, MARR, BURI, GRAD, etc.

  media        MediaObject @relation("MediaEvents", fields: [mediaId], references: [id], onDelete: Cascade)
  person       Person      @relation("PersonEventMedia", fields: [personId], references: [id], onDelete: Cascade)

  @@unique([mediaId, personId, eventType])
  @@index([mediaId])
  @@index([personId])
  @@index([eventType])
}
